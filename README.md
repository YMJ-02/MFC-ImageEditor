# 🖼️ C++ MFC 이미지 편집기 (MFC Image Editor)

C++ MFC와 GDI+를 사용하여 개발한 간단한 이미지 편집 프로그램입니다. 이 프로젝트는 MFC의 문서/뷰 아키텍처를 이해하고, GDI+를 활용한 이미지 처리 기법을 학습하는 데 중점을 두었습니다.


<br>

## ✨ 주요 기능

-   **이미지 열기 및 저장**: 다양한 형식의 이미지 파일을 열고, PNG 형식으로 저장할 수 있습니다.
-   **그레이스케일 필터**: 이미지를 흑백으로 변환합니다.
-   **특정 색상 유지 필터 (스포이드)**: 사용자가 스포이드로 선택한 색상과 **유사한 색상 범위(Tolerance)**에 있는 모든 픽셀은 색상을 유지하고, 나머지 영역은 모두 흑백으로 처리합니다.
-   **작업 되돌리기**: 이미지에 적용된 마지막 작업을 이전 상태로 되돌립니다.
-   **창 자동 조절**: 불러온 이미지의 크기에 맞게 프로그램 창의 크기가 자동으로 조절됩니다.

<br>

## 🛠️ 사용 기술

-   **C++**
-   **MFC (Microsoft Foundation Class)**
-   **GDI+**

<br>

## 💡 주요 학습 내용 및 문제 해결

이 프로젝트를 진행하며 발생했던 주요 기술적 문제와 해결 과정을 공유합니다.

### 1. MFC의 `DEBUG_NEW`와 GDI+의 `new` 연산자 충돌

-   **문제**: 디버그 모드에서 MFC는 메모리 누수 탐지를 위해 `new`를 `DEBUG_NEW`로 재정의합니다. 이 때문에 GDI+ 객체(`Gdiplus::Bitmap` 등)를 생성할 때 `new` 연산자가 충돌하여 컴파일 오류가 발생했습니다.
-   **해결**: GDI+ 객체를 생성하는 코드 바로 앞뒤에서 `#undef new`와 `#define new DEBUG_NEW` 전처리기 지시문을 사용하여 일시적으로 MFC의 매크로 재정의를 비활성화하는 방식으로 문제를 해결했습니다.

### 2. `Gdiplus::Image`와 `Gdiplus::Bitmap` 형식 문제

-   **문제**: 스포이드 기능 구현 시, `Image::FromFile`로 불러온 이미지의 특정 픽셀 색상 값을 읽으려고 할 때 기능이 동작하지 않았습니다. 원인은 `Image::FromFile`이 반환하는 `Gdiplus::Image` 포인터가 픽셀 직접 접근이 불가능한 일반 이미지 형식을 가리킬 수 있기 때문이었습니다.
-   **해결**: `dynamic_cast`를 통해 이 문제를 진단했으며, 이미지를 불러올 때나 '되돌리기' 기능을 실행할 때 항상 새로운 `Gdiplus::Bitmap` 객체를 생성하고 그 위에 원본 이미지를 그려넣는 방식으로 `m_pImg` 포인터가 언제나 픽셀 접근이 가능한 비트맵 객체를 가리키도록 보장하여 문제를 해결했습니다.

<br>

## 🚀 실행 방법

1.  이 리포지토리를 로컬 컴퓨터에 클론(Clone)합니다.
2.  Visual Studio에서 `ImageEdit.sln` 파일을 엽니다.
3.  `F5` 키를 누르거나 '빌드' -> '솔루션 빌드' 후 실행하여 프로그램을 시작합니다.
